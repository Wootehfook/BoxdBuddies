# AI Generated: GitHub Copilot - 2025-08-18
# Automated PR Conversation Handler - Self-Healing CI/CD Component
name: "ü§ñ PR Conversation Handler"

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted]
  # AI Generated: GitHub Copilot - 2025-08-18
  # Trigger on creation/edits of review comments which represent PR conversations
  pull_request_review_comment:
    types: [created, edited]
  schedule:
    # Run daily at 9 AM UTC to check all open PRs
    - cron: "0 9 * * *"
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to check (leave empty for all open PRs)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write

jobs:
  check-conversations:
    name: "üîç Check Unresolved Conversations"
    runs-on: ubuntu-latest
    outputs:
      has_unresolved: ${{ steps.check.outputs.has_unresolved }}
      auto_fixable: ${{ steps.check.outputs.auto_fixable }}
      manual_review: ${{ steps.check.outputs.manual_review }}
    steps:
      - name: üèóÔ∏è Checkout Repository
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: "üîç Check Unresolved Conversations"
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            // GitHub Script provides: github, context, core

            // Determine which PRs to check
            let prsToCheck = [];
            if (context.eventName === 'schedule' || context.eventName === 'workflow_dispatch') {
              const prInput = context.payload?.inputs?.pr_number;
              if (prInput) {
                prsToCheck = [parseInt(prInput)];
              } else {
                // Get all open PRs
                const { data: openPRs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open'
                });
                prsToCheck = openPRs.map(pr => pr.number);
              }
            } else {
              // PR event - check the current PR
              prsToCheck = [context.payload.pull_request?.number || context.payload.review?.pull_request?.number];
            }

            let totalUnresolved = 0;
            let autoFixable = [];
            let manualReview = [];

            for (const prNumber of prsToCheck) {
              if (!prNumber) continue;

              console.log(`üîç Checking PR #${prNumber} for unresolved conversations...`);

              try {
                // Get review comments
                const { data: comments } = await github.rest.pulls.listReviewComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });

                // Get reviews to check resolution status
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });

                // Analyze unresolved conversations
                for (const comment of comments) {
                  const conversationResolved = await checkConversationResolved(comment, reviews);

                  if (!conversationResolved) {
                    const analysis = analyzeComment(comment);

                    // Skip automated or stale comments
                    if (analysis.skip) {
                      console.log(`‚è≠Ô∏è Skipping comment: ${analysis.reason}`);
                      continue;
                    }

                    totalUnresolved++;

                    if (analysis.autoFixable) {
                      autoFixable.push({
                        pr: prNumber,
                        commentId: comment.id,
                        file: comment.path,
                        line: comment.line,
                        type: analysis.type,
                        suggestion: analysis.suggestion,
                        body: comment.body
                      });
                    } else {
                      manualReview.push({
                        pr: prNumber,
                        commentId: comment.id,
                        file: comment.path,
                        line: comment.line || 'N/A',
                        body: comment.body,
                        reason: analysis.reason
                      });
                    }
                  }
                }
              } catch (error) {
                console.error(`‚ùå Error checking PR #${prNumber}:`, error.message);
              }
            }

            // Helper functions
            async function checkConversationResolved(comment, reviews) {
              // Simple heuristic: if there's a newer review after the comment, consider it addressed
              const commentTime = new Date(comment.created_at);
              return reviews.some(review =>
                new Date(review.submitted_at) > commentTime &&
                review.state !== 'COMMENTED'
              );
            }

            function analyzeComment(comment) {
              const body = comment.body.toLowerCase();

              // Skip if this is a GitHub automated comment or action
              if (body.includes('github-actions') || body.includes('codecov') || body.includes('dependabot')) {
                return {
                  autoFixable: false,
                  reason: 'Automated comment - no action needed',
                  skip: true
                };
              }

              // Skip if line number is null or undefined (often indicates stale comments)
              if (!comment.line && !comment.start_line) {
                return {
                  autoFixable: false,
                  reason: 'Stale comment with no line reference - likely resolved',
                  skip: true
                };
              }

              // AI attribution timestamp pattern
              if (body.includes('ai attribution') && body.includes('timestamp')) {
                return {
                  autoFixable: true,
                  type: 'ai-attribution-timestamp',
                  suggestion: 'Update AI attribution timestamp to current date'
                };
              }

              // Axios configuration pattern
              if (body.includes('axios') && body.includes('timeout')) {
                return {
                  autoFixable: true,
                  type: 'axios-configuration',
                  suggestion: 'Add axios timeout and interceptors configuration'
                };
              }

              // Error handling pattern
              if (body.includes('error handling') && body.includes('specific')) {
                return {
                  autoFixable: true,
                  type: 'error-handling',
                  suggestion: 'Improve error handling with specific messages'
                };
              }

              // URL validation (security - manual review)
              if (body.includes('url') && (body.includes('validation') || body.includes('security'))) {
                return {
                  autoFixable: false,
                  reason: 'Security-related URL validation requires manual review'
                };
              }

              // Common false positives to skip
              if (body.includes('looks good') || body.includes('lgtm') || body.includes('approved')) {
                return {
                  autoFixable: false,
                  reason: 'Positive review comment - no action needed',
                  skip: true
                };
              }

              // Default to manual review for unknown patterns, but be more descriptive
              return {
                autoFixable: false,
                reason: `Review comment requires attention: "${comment.body.substring(0, 50)}${comment.body.length > 50 ? '...' : ''}"`
              };
            }

            // Set outputs
            core.setOutput('has_unresolved', (totalUnresolved > 0).toString());
            core.setOutput('auto_fixable', JSON.stringify(autoFixable));
            core.setOutput('manual_review', JSON.stringify(manualReview));

            // Create summary
            core.summary
              .addHeading('ü§ñ PR Conversation Analysis')
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Count', header: true}],
                ['Total Unresolved', totalUnresolved.toString()],
                ['Auto-fixable', autoFixable.length.toString()],
                ['Manual Review Needed', manualReview.length.toString()]
              ]);

            if (autoFixable.length > 0) {
              core.summary.addHeading('üîß Auto-fixable Issues', 3);
              autoFixable.forEach(item => {
                core.summary.addRaw(`- **${item.type}** in \`${item.file}\` (line ${item.line}): ${item.suggestion}`);
              });
            }

            if (manualReview.length > 0) {
              core.summary.addHeading('üëÄ Manual Review Required', 3);
              manualReview.forEach(item => {
                core.summary.addRaw(`- \`${item.file}\` (line ${item.line}): ${item.reason}`);
              });
            }

            await core.summary.write();

            console.log(`‚úÖ Analysis complete: ${totalUnresolved} unresolved, ${autoFixable.length} auto-fixable, ${manualReview.length} manual review`);

  auto-fix:
    name: "üîß Apply Automatic Fixes"
    runs-on: ubuntu-latest
    needs: check-conversations
    # AI Generated: GitHub Copilot - 2025-08-18
    # Only attempt auto-fixes when running on a PR event (not schedule/dispatch),
    # there are unresolved conversations with auto-fixable items, and the PR is not from a fork.
    if: github.event_name == 'pull_request' && needs['check-conversations'].outputs.has_unresolved == 'true' && needs['check-conversations'].outputs.auto_fixable != '[]' && !github.event.pull_request.head.repo.fork
    steps:
      - name: üèóÔ∏è Checkout Repository
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: "üîß Apply Automatic Fixes"
        uses: actions/github-script@v8
        env:
          AUTO_FIXABLE_JSON: ${{ needs['check-conversations'].outputs.auto_fixable }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const today = new Date().toISOString().slice(0, 10);

            // Use environment variable to safely get the JSON data
            let autoFixable = [];
            try {
              const rawOutput = process.env.AUTO_FIXABLE_JSON || '[]';
              autoFixable = JSON.parse(rawOutput);
              console.log(`Parsed ${autoFixable.length} auto-fixable items`);
            } catch (error) {
              console.log('Error parsing auto-fixable output, using empty array:', error.message);
              autoFixable = [];
            }

            let filesModified = [];

            for (const fix of autoFixable) {
              console.log(`üîß Applying fix for ${fix.type} in ${fix.file}`);
              try {
                const filePath = fix.file;
                let content = fs.readFileSync(filePath, 'utf8');
                let modified = false;

                switch (fix.type) {
                  case 'ai-attribution-timestamp': {
                    // Update AI attribution timestamps to the current date
                    const aiAttributionRegex = /\/\/ AI Generated: GitHub Copilot - \d{4}-\d{2}-\d{2}/g;
                    if (aiAttributionRegex.test(content)) {
                      content = content.replace(aiAttributionRegex, `// AI Generated: GitHub Copilot - ${today}`);
                      modified = true;
                    }
                    break;
                  }
                  case 'axios-configuration': {
                    // Add axios configuration if missing
                    if (content.includes('import axios from "axios"') && !content.includes('axios.create')) {
                      const axiosImportRegex = /(import axios from "axios";)/;
                      const axiosConfig = '$1\n\n// AI Generated: GitHub Copilot - ' + today + '\n// Create a configured axios instance with timeout and interceptors\nconst axiosInstance = axios.create({\n  timeout: 10000, // 10 seconds timeout\n});\n\n// Request interceptor for logging and headers\naxiosInstance.interceptors.request.use(\n  (config) => {\n    return config;\n  },\n  (error) => {\n    console.error("Request error:", error);\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor for error handling\naxiosInstance.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    if (error.code === "ECONNABORTED") {\n      console.error("Request timeout:", error.message);\n    } else if (error.response) {\n      console.error("Response error:", error.response.status, error.response.data);\n    } else {\n      console.error("Network or unknown error:", error.message);\n    }\n    return Promise.reject(error);\n  }\n);';
                      content = content.replace(axiosImportRegex, axiosConfig);
                      modified = true;
                    }
                    break;
                  }
                  case 'error-handling': {
                    // Improve basic error handling patterns
                    const basicErrorRegex = /catch \(err\) \{[\s\S]*?setError\(err instanceof Error \? err\.message : ['"](.+?)['"];?\)/g;
                    const before = content;
                    content = content.replace(basicErrorRegex, (match, fallbackMsg) => {
                      return match.replace(fallbackMsg, 'Failed operation: ' + fallbackMsg + '. Please check your connection and try again.');
                    });
                    if (before !== content) {
                      modified = true;
                    }
                    break;
                  }
                }

                if (modified) {
                  fs.writeFileSync(filePath, content, 'utf8');
                  filesModified.push(filePath);
                  console.log(`‚úÖ Applied ${fix.type} fix to ${filePath}`);
                }
              } catch (error) {
                console.error(`‚ùå Failed to apply fix to ${fix.file}:`, error.message);
              }
            }

            // Store modified files for commit step
            fs.writeFileSync('modified-files.json', JSON.stringify(filesModified));

            console.log(`üéØ Applied fixes to ${filesModified.length} files`);

      - name: "üìù Commit Automatic Fixes"
        run: |
          if [ -f "modified-files.json" ]; then
            MODIFIED_FILES=$(cat modified-files.json)
            if [ "$MODIFIED_FILES" != "[]" ]; then
              git config --local user.email "action@github.com"
              git config --local user.name "GitHub Action - PR Conversation Handler"

              # Add only the modified files
              echo "$MODIFIED_FILES" | jq -r '.[]' | xargs git add

              git commit -m "ü§ñ Auto-fix: Address unresolved PR conversations

              - Updated AI attribution timestamps to current date
              - Enhanced axios configuration with timeouts and interceptors  
              - Improved error handling with specific messages

              Applied by automated PR conversation handler
              Co-authored-by: GitHub Copilot <copilot@github.com>"

              git push
              echo "‚úÖ Committed automatic fixes"
            else
              echo "‚ÑπÔ∏è No files were modified"
            fi
          else
            echo "‚ÑπÔ∏è No fixes were applied"
          fi

  report:
    name: "üìä Generate Report"
    runs-on: ubuntu-latest
    # Only depend on the analysis job so this job can always run even if auto-fix is skipped
    needs: check-conversations
    # AI Generated: GitHub Copilot - 2025-08-18
    # Always run so the required check doesn't appear as Skipped.
    if: ${{ always() }}
    steps:
      - name: "üìä Comment on PR"
        # Only post a PR comment on PR-related events and when unresolved items exist
        if: ${{ (github.event_name == 'pull_request' || startsWith(github.event_name, 'pull_request_')) && needs['check-conversations'].outputs.has_unresolved == 'true' }}
        uses: actions/github-script@v8
        env:
          AUTO_FIXABLE_JSON: ${{ needs['check-conversations'].outputs.auto_fixable }}
          MANUAL_REVIEW_JSON: ${{ needs['check-conversations'].outputs.manual_review }}
        with:
          script: |
            // GitHub Script provides: github, context, core
            // Use environment variables to safely get the JSON data
            let autoFixable = [];
            let manualReview = [];

            try {
              const rawAutoFixable = process.env.AUTO_FIXABLE_JSON || '[]';
              autoFixable = JSON.parse(rawAutoFixable);
              console.log(`Parsed ${autoFixable.length} auto-fixable items`);
            } catch (error) {
              console.log('Error parsing auto-fixable output:', error.message);
              autoFixable = [];
            }

            try {
              const rawManualReview = process.env.MANUAL_REVIEW_JSON || '[]';
              manualReview = JSON.parse(rawManualReview);
              console.log(`Parsed ${manualReview.length} manual review items`);
            } catch (error) {
              console.log('Error parsing manual-review output:', error.message);
              manualReview = [];
            }

            // Only comment on PR events, not scheduled runs
            if (context.eventName.startsWith('pull_request') && context.payload.pull_request) {
              const prNumber = context.payload.pull_request.number;

              let comment = `## ü§ñ PR Conversation Handler Report\n\n`;

              if (autoFixable.length > 0) {
                comment += `### ‚úÖ Automatic Fixes Applied (${autoFixable.length})\n\n`;
                autoFixable.forEach(fix => {
                  comment += `- **${fix.type}** in \`${fix.file}\`: ${fix.suggestion}\n`;
                });
                comment += `\n*These issues have been automatically resolved.*\n\n`;
              }

              if (manualReview.length > 0) {
                comment += `### üëÄ Manual Review Required (${manualReview.length})\n\n`;
                manualReview.forEach(item => {
                  comment += `- \`${item.file}\` (line ${item.line}): ${item.reason}\n`;
                });
                comment += `\n*Please address these issues manually before merging.*\n\n`;
              }

              if (autoFixable.length === 0 && manualReview.length === 0) {
                comment += `### üéâ All Conversations Resolved!\n\nNo unresolved review conversations found.\n\n`;
              }

              comment += `---\n*This is an automated message from the self-healing CI/CD system.*`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
            }

      - name: "üö® Set Check Status"
        uses: actions/github-script@v8
        env:
          MANUAL_REVIEW_JSON: ${{ needs['check-conversations'].outputs.manual_review }}
        with:
          script: |
            // Use environment variable to safely get the JSON data
            let manualReview = [];
            try {
              const rawManualReview = process.env.MANUAL_REVIEW_JSON || '[]';
              manualReview = JSON.parse(rawManualReview);
              console.log(`Parsed ${manualReview.length} manual review items`);
            } catch (error) {
              console.log('Error parsing manual-review output:', error.message);
              manualReview = [];
            }

            // Do not fail the job; emit a warning to keep this check non-blocking
            if (manualReview.length > 0) {
              core.warning(`${manualReview.length} unresolved conversations require manual review`);
            } else {
              console.log("‚úÖ All conversations resolved or auto-fixed");
            }

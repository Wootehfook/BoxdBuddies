name: Update Changelog on PR Merge

on:
  workflow_run:
    workflows:
      - Changelog Update Gate
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  update-changelog:
    if: >-
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.repository.full_name == github.repository
    runs-on: ubuntu-latest
    steps:
      - name: Validate release PR token
        env:
          RELEASE_PR_TOKEN: ${{ secrets.RELEASE_PR_TOKEN }}
        run: |
          if [ -z "$RELEASE_PR_TOKEN" ]; then
            echo "::error::RELEASE_PR_TOKEN secret is required to create PRs that trigger required checks."
            echo "Create a PAT with repo permissions, store it as RELEASE_PR_TOKEN, then re-run."
            exit 1
          fi

      - name: Load PR context
        id: pr_context
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PR_TOKEN }}
        run: |
          PR_NUMBER=$(jq -r '.workflow_run.pull_requests[0].number // empty' "$GITHUB_EVENT_PATH")
          if [ -z "$PR_NUMBER" ]; then
            echo "::error::No pull request found on workflow_run payload."
            exit 1
          fi

          gh api "repos/${{ github.repository }}/pulls/$PR_NUMBER" > /tmp/pr.json

          PR_BASE=$(jq -r '.base.ref' /tmp/pr.json)
          PR_MERGED=$(jq -r '.merged' /tmp/pr.json)
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV
          echo "PR_BASE=$PR_BASE" >> $GITHUB_ENV
          echo "PR_MERGED=$PR_MERGED" >> $GITHUB_ENV

      - name: Evaluate changelog guard
        id: skip_guard
        run: |
          if [ "$PR_MERGED" != "true" ]; then
            echo "PR not merged; skipping changelog update."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          PR_TITLE=$(jq -r '.title' /tmp/pr.json)
          PR_BRANCH=$(jq -r '.head.ref' /tmp/pr.json)
          PR_BODY=$(jq -r '.body // ""' /tmp/pr.json)
          if [[ "$PR_BRANCH" =~ ^changelog/update-pr- ]]; then
            echo "Skipping changelog update PR (branch guard) to avoid recursion."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [[ "$PR_BODY" == *"<!-- changelog-update -->"* ]]; then
            echo "Skipping changelog update PR (body marker) to avoid recursion."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [[ "$PR_TITLE" =~ ^docs(\(.*\))?:\ update\ CHANGELOG ]]; then
            echo "Skipping changelog-only PR to avoid recursion."
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Checkout repository
        if: steps.skip_guard.outputs.skip != 'true'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          ref: ${{ env.PR_BASE }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        if: steps.skip_guard.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Extract PR information
        if: steps.skip_guard.outputs.skip != 'true'
        id: pr_info
        run: |
          PR_TITLE=$(jq -r '.title' /tmp/pr.json)
          PR_NUMBER=$(jq -r '.number' /tmp/pr.json)
          PR_AUTHOR=$(jq -r '.user.login' /tmp/pr.json)

          # Sanitize PR title â€” strip dangerous shell metacharacters
          if [[ "$PR_TITLE" =~ [\;\|\&\`\$\(\)\<\>] ]]; then
            echo "Warning: PR title contains potentially dangerous characters"
            PR_TITLE=$(printf '%s\n' "$PR_TITLE" | tr -d ';|&`$()<>' | tr '\n' ' ')
          fi

          # Fallback if title is empty after sanitization
          PR_TITLE_TRIMMED=$(echo "$PR_TITLE" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')
          if [ -z "$PR_TITLE_TRIMMED" ]; then
            echo "Warning: PR title is empty after sanitization; using fallback"
            PR_TITLE="PR #$PR_NUMBER"
          else
            PR_TITLE="$PR_TITLE_TRIMMED"
          fi

          echo "title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "number=$PR_NUMBER" >> $GITHUB_OUTPUT

          # Determine change type from conventional commit prefix
          CHANGE_TYPE="Changed"
          FOLLOWS_CONVENTION=false

          if [[ "$PR_TITLE" =~ ^feat(\(.*\))?:.*$ ]]; then
            CHANGE_TYPE="Added"; FOLLOWS_CONVENTION=true
          elif [[ "$PR_TITLE" =~ ^fix(\(.*\))?:.*$ ]]; then
            CHANGE_TYPE="Fixed"; FOLLOWS_CONVENTION=true
          elif [[ "$PR_TITLE" =~ ^(chore|docs|refactor|perf|test|build|ci)(\(.*\))?:.*$ ]]; then
            CHANGE_TYPE="Changed"; FOLLOWS_CONVENTION=true
          fi

          echo "change_type=$CHANGE_TYPE" >> $GITHUB_OUTPUT
          echo "follows_convention=$FOLLOWS_CONVENTION" >> $GITHUB_OUTPUT

          # Clean PR title (strip conventional commit prefix, capitalise first letter)
          CLEAN_TITLE=$(echo "$PR_TITLE" | sed -E 's/^(feat|fix|chore|docs|refactor|perf|test|build|ci)(\([^)]*\))?:[[:space:]]*//')
          CLEAN_TITLE=$(echo "$CLEAN_TITLE" | awk '{print toupper(substr($0,1,1)) substr($0,2)}')
          echo "clean_title=$CLEAN_TITLE" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        if: steps.skip_guard.outputs.skip != 'true'
        run: |
          CHANGE_TYPE="${{ steps.pr_info.outputs.change_type }}"
          CLEAN_TITLE="${{ steps.pr_info.outputs.clean_title }}"
          PR_NUMBER="${{ steps.pr_info.outputs.number }}"

          # Write title to a file to avoid embedding it directly in the awk command
          printf '%s\n' "$CLEAN_TITLE" > /tmp/pr_title

          # Use awk to insert the new entry under the correct ### subsection
          awk -v type="$CHANGE_TYPE" -v pr="$PR_NUMBER" '
          BEGIN {
            found_unreleased=0;
            added_entry=0;
            blank_lines=0;
            if ((getline title < "/tmp/pr_title") > 0) {
              # title loaded from file
            }
            close("/tmp/pr_title");
          }

          # When we find the Unreleased section
          /## \[Unreleased\]/ {
            print $0;
            found_unreleased=1;
            blank_lines=0;
            next;
          }

          # Track blank lines inside the Unreleased section
          found_unreleased && !added_entry && /^[[:space:]]*$/ {
            blank_lines++;
            next;
          }

          # Found the matching ### subsection â€” append the entry
          found_unreleased && !added_entry && $0 ~ "^### " type {
            for (i = 0; i < blank_lines; i++) print "";
            blank_lines=0;
            print $0;
            print "- " title " (#" pr ")";
            added_entry=1;
            next;
          }

          # Hit the next version section without finding the subsection â€” create it
          found_unreleased && !added_entry && /^## \[/ {
            print "";
            print "### " type;
            print "- " title " (#" pr ")";
            print "";
            blank_lines=0;
            added_entry=1;
            found_unreleased=0;
            print $0;
            next;
          }

          # Another subsection in Unreleased that is not our type â€” print as-is
          found_unreleased && !added_entry && /^### / {
            for (i = 0; i < blank_lines; i++) print "";
            blank_lines=0;
            print $0;
            next;
          }

          # Default: print all other lines
          {
            if (found_unreleased && !added_entry && blank_lines > 0) {
              for (i = 0; i < blank_lines; i++) print "";
              blank_lines=0;
            }
            print $0;
          }
          ' CHANGELOG.md > /tmp/changelog_updated.md

          # If CHANGELOG.md had no [Unreleased] section, prepend one
          if ! grep -q "## \[Unreleased\]" /tmp/changelog_updated.md; then
            {
              head -n 6 CHANGELOG.md
              echo ""
              echo "## [Unreleased]"
              echo ""
              echo "### $CHANGE_TYPE"
              echo "- $CLEAN_TITLE (#$PR_NUMBER)"
              echo ""
              tail -n +7 CHANGELOG.md
            } > /tmp/changelog_updated.md
          fi

          mv /tmp/changelog_updated.md CHANGELOG.md

      - name: Commit and open changelog PR
        if: steps.skip_guard.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if git diff --quiet CHANGELOG.md; then
            echo "No changes to CHANGELOG.md"
            exit 0
          fi

          BRANCH_NAME="changelog/update-pr-${{ steps.pr_info.outputs.number }}"

          # Avoid duplicates â€” check for an existing PR or remote branch
          EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number -q '.[0].number')
          if [ -n "$EXISTING_PR" ]; then
            echo "Changelog PR already exists: #$EXISTING_PR"
            exit 0
          fi

          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            echo "Remote changelog branch already exists: $BRANCH_NAME"
            exit 0
          fi

          git checkout -b "$BRANCH_NAME"
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG for PR #${{ steps.pr_info.outputs.number }}"
          git push origin "$BRANCH_NAME"

          gh pr create \
            --title "docs: update CHANGELOG for PR #${{ steps.pr_info.outputs.number }}" \
            --body $'Automated changelog update for #${{ steps.pr_info.outputs.number }}.\n\n<!-- changelog-update -->' \
            --base "${{ github.event.pull_request.base.ref }}" \
            --head "$BRANCH_NAME"

      - name: Comment on PR
        if: success() && steps.skip_guard.outputs.skip != 'true'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          COMMENT="âœ… CHANGELOG.md has been automatically updated with this PR's changes in the **${{ steps.pr_info.outputs.change_type }}** section."
          if [[ "${{ steps.pr_info.outputs.follows_convention }}" != "true" ]]; then
            COMMENT="${COMMENT}\n\nðŸ’¡ **Tip:** Your PR title doesn't follow the conventional commit format (e.g., \`feat:\`, \`fix:\`, \`chore:\`). Changes were categorised as '**Changed**' by default."
          fi

          gh pr comment ${{ steps.pr_info.outputs.number }} --body "$COMMENT"

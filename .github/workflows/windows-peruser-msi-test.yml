name: Windows Per-User MSI Test

on:
  workflow_dispatch:
  push:
    branches:
      - chore/release-checksum
      - chore/linux-ubuntu-compat-symlinks
  pull_request:
    branches:
      - main

permissions:
  contents: read
  actions: read

jobs:
  per-user-msi:
    runs-on: windows-latest
    env:
      # AI Generated: GitHub Copilot - 2025-08-08 (enable sccache for faster Rust builds)
      RUSTC_WRAPPER: sccache
      SCCACHE_CACHE_SIZE: 2G
      CARGO_INCREMENTAL: 0
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.4

      - name: Cache sccache
        uses: actions/cache@v4
        with:
          path: |
            ~\AppData\Local\Mozilla\sccache
          key: peruser-win-sccache-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            peruser-win-sccache-

      - name: Cache cargo
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            src-tauri/target
          key: peruser-win-cargo-${{ hashFiles('src-tauri/Cargo.lock') }}
          restore-keys: |
            peruser-win-cargo-

      - name: Install dependencies
        run: npm ci

      - name: Build per-user MSI
        # AI Generated: GitHub Copilot - 2025-08-07
        env:
          RUST_LOG: tauri_bundler=trace,tauri=debug
          TAURI_LOG_LEVEL: debug
          TAURI_BUNDLER_DEBUG: "1"
        shell: pwsh
        run: |
          Write-Host "Starting verbose Tauri MSI build (per-user)"
          npx tauri build --verbose --config src-tauri/tauri.windows.conf.json --bundles msi

      - name: sccache stats
        shell: pwsh
        run: |
          if (Get-Command sccache -ErrorAction SilentlyContinue) {
            sccache --show-stats
          } else {
            Write-Host "sccache not available"
          }

      - name: Debug WiX artifacts (on failure)
        if: failure()
        shell: pwsh
        run: |
          Write-Host 'Listing MSI bundle directory contents:'
            Get-ChildItem -Recurse src-tauri/target/release/bundle/msi | Select-Object FullName, Length | Format-Table -AutoSize
          Write-Host 'Searching TEMP for WiX intermediate files:'
          Get-ChildItem -Recurse "$env:TEMP" -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '\\.wix(obj|pdb|out|log)$' } | Select-Object -First 100 FullName, Length | Format-Table -AutoSize
          Write-Host 'Done collecting WiX diagnostics.'

      - name: Upload WiX diagnostics (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: wix-diagnostics
          path: |
            src-tauri/target/release/bundle/msi
            !src-tauri/target/release/bundle/msi/*.msi
            ${{ runner.temp }}/**/*.wix*
          if-no-files-found: warn

      - name: Locate MSI
        id: find_msi
        shell: pwsh
        run: |
          $msi = Get-ChildItem -Path src-tauri/target/release/bundle/msi -Filter *.msi -Recurse | Select-Object -First 1
          if (-not $msi) { Write-Error 'MSI not found'; exit 1 }
          Write-Host "Found MSI: $($msi.FullName)"
          echo "msi_path=$($msi.FullName)" >> $env:GITHUB_OUTPUT

      - name: Verify per-user install context
        shell: pwsh
        run: |
          # AI Generated: GitHub Copilot - 2025-08-07
          $msiPath = '${{ steps.find_msi.outputs.msi_path }}'
          Write-Host "Inspecting MSI: $msiPath"
          $installer = New-Object -ComObject WindowsInstaller.Installer
          $database = $installer.GetType().InvokeMember('OpenDatabase',[System.Reflection.BindingFlags]::InvokeMethod,$null,$installer,@($msiPath,0))
          $view = $database.GetType().InvokeMember('OpenView',[System.Reflection.BindingFlags]::InvokeMethod,$null,$database,@("SELECT `Value` FROM `Property` WHERE `Property`='ALLUSERS'"))
          $view.GetType().InvokeMember('Execute',[System.Reflection.BindingFlags]::InvokeMethod,$null,$view,$null) | Out-Null
          $record = $view.GetType().InvokeMember('Fetch',[System.Reflection.BindingFlags]::InvokeMethod,$null,$view,$null)
          if (-not $record) {
            Write-Warning 'ALLUSERS property not present (expected for pure per-user package). Treating as per-user.'
            Write-Host 'Per-user MSI validation passed (ALLUSERS absent).'
            exit 0
          }
          $value = $record.GetType().InvokeMember('StringData',[System.Reflection.BindingFlags]::GetProperty,$null,$record,1)
          Write-Host "ALLUSERS=$value"
          if ($value -eq '1') {
            Write-Error "Detected machine-wide ALLUSERS=1; expected per-user (missing or !=1)."; exit 1
          }
          Write-Host 'Per-user MSI validation passed (ALLUSERS not 1).'

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: per-user-msi
          path: ${{ steps.find_msi.outputs.msi_path }}
          if-no-files-found: error
